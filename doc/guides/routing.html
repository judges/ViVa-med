<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Rails Routing from the Outside In</title>

<link rel="stylesheet" type="text/css" href="files/stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/syntax.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/print.css" media="print" />

<script type="text/javascript" src="files/javascripts/guides.js"></script>
<script type="text/javascript" src="files/javascripts/code_highlighter.js"></script>
<script type="text/javascript" src="files/javascripts/highlighters.js"></script>

</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/overview">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="activerecord_validations_callbacks.html">Active Record Validations and Callbacks</a></dd>
              <dd><a href="association_basics.html">Active Record Associations</a></dd>
              <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
              <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
              <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
            </dl>
            <dl class="R">
              <dt>Digging Deeper</dt>
              <dd><a href="i18n.html">Rails Internationalization API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
              <dd><a href="testing.html">Testing Rails Applications</a></dd>
              <dd><a href="security.html">Securing Rails Applications</a></dd>
              <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
              <dd><a href="performance_testing.html">Performance Testing Rails Applications</a></dd>
              <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
              <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
              <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
              <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
              <dd><a href="caching_with_rails.html">Caching with Rails</a></dd>
              <dd><a href="contributing_to_rails.html">Contributing to Rails</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contribute.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Rails Routing from the Outside In</h2>
<p>This guide covers the user-facing features of Rails routing. By referring to this guide, you will be able to:</p>
<ul>
	<li>Understand the purpose of routing</li>
	<li>Decipher the code in <tt>routes.rb</tt></li>
	<li>Construct your own routes, using either the classic hash style or the now-preferred RESTful style</li>
	<li>Identify how a route will map to a controller and action</li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#the-dual-purpose-of-routing">The Dual Purpose of Routing</a><ul><li><a href="#connecting-urls-to-code">Connecting URLs to Code</a></li><li><a href="#generating-urls-from-code">Generating URLs from Code</a></li></ul></li><li><a href="#quick-tour-of-routesrb">Quick Tour of <tt>routes.rb</tt></a><ul><li><a href="#processing-the-file">Processing the File</a></li><li><a href="#restful-routes">RESTful Routes</a></li><li><a href="#named-routes">Named Routes</a></li><li><a href="#nested-routes">Nested Routes</a></li><li><a href="#regular-routes">Regular Routes</a></li><li><a href="#default-routes">Default Routes</a></li></ul></li><li><a href="#restful-routing-the-rails-default">RESTful Routing: the Rails Default</a><ul><li><a href="#what-is-rest">What is <span class="caps">REST</span>?</a></li><li><a href="#crud-verbs-and-actions"><span class="caps">CRUD</span>, Verbs, and Actions</a></li><li><a href="#urls-and-paths">URLs and Paths</a></li><li><a href="#defining-multiple-resources-at-the-same-time">Defining Multiple Resources at the Same Time</a></li><li><a href="#singular-resources">Singular Resources</a></li><li><a href="#customizing-resources">Customizing Resources</a></li><li><a href="#controller-namespaces-and-routing">Controller Namespaces and Routing</a></li><li><a href="#nested-resources">Nested Resources</a></li><li><a href="#route-generation-from-arrays">Route Generation from Arrays</a></li><li><a href="#namespaced-resources">Namespaced Resources</a></li><li><a href="#adding-more-restful-actions">Adding More RESTful Actions</a></li></ul></li><li><a href="#regular-routes">Regular Routes</a><ul><li><a href="#bound-parameters">Bound Parameters</a></li><li><a href="#wildcard-components">Wildcard Components</a></li><li><a href="#static-text">Static Text</a></li><li><a href="#querystring-parameters">Querystring Parameters</a></li><li><a href="#defining-defaults">Defining Defaults</a></li><li><a href="#named-routes">Named Routes</a></li><li><a href="#route-requirements">Route Requirements</a></li><li><a href="#route-conditions">Route Conditions</a></li><li><a href="#route-globbing">Route Globbing</a></li><li><a href="#route-options">Route Options</a></li></ul></li><li><a href="#formats-and-respond-to">Formats and <tt>respond_to</tt></a><ul><li><a href="#specifying-the-format-with-an-http-header">Specifying the Format with an <span class="caps">HTTP</span> Header</a></li><li><a href="#recognized-mime-types">Recognized <span class="caps">MIME</span> types</a></li></ul></li><li><a href="#the-default-routes">The Default Routes</a><ul></ul></li><li><a href="#the-empty-route">The Empty Route</a><ul><li><a href="#using-maproot">Using <tt>map.root</tt></a></li><li><a href="#connecting-the-empty-string">Connecting the Empty String</a></li></ul></li><li><a href="#inspecting-and-testing-routes">Inspecting and Testing Routes</a><ul><li><a href="#seeing-existing-routes-with-rake">Seeing Existing Routes with <tt>rake</tt></a></li><li><a href="#testing-routes">Testing Routes</a></li></ul></li><li><a href="#changelog">Changelog</a><ul></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="the-dual-purpose-of-routing">1 The Dual Purpose of Routing</h3>
<p>Rails routing is a two-way piece of machinery &#8211; rather as if you could turn trees into paper, and then turn paper back into trees. Specifically, it both connects incoming <span class="caps">HTTP</span> requests to the code in your application&#8217;s controllers, and helps you generate URLs without having to hard-code them as strings.</p>
<h4 id="connecting-urls-to-code">1.1 Connecting URLs to Code</h4>
<p>When your Rails application receives an incoming <span class="caps">HTTP</span> request, say</p>
<pre>
GET /patients/17
</pre>
<p>the routing engine within Rails is the piece of code that dispatches the request to the appropriate spot in your application. In this case, the application would most likely end up running the <tt>show</tt> action within the <tt>patients</tt> controller, displaying the details of the patient whose ID is 17.</p>
<h4 id="generating-urls-from-code">1.2 Generating URLs from Code</h4>
<p>Routing also works in reverse. If your application contains this code:</p>
<div class="code_container"><code class="ruby">
@patient = Patient.find(17)
</code></div>
<div class="code_container"><code class="html">
&lt;%= link_to &quot;Patient Record&quot;, patient_path(@patient) %&gt;
</code></div>
<p>Then the routing engine is the piece that translates that to a link to a <span class="caps">URL</span> such as <tt>http://example.com/patients/17</tt>. By using routing in this way, you can reduce the brittleness of your application as compared to one with hard-coded URLs, and make your code easier to read and understand.</p>
<div class='note'><p>Patient needs to be declared as a resource for this style of translation via a named route to be available.</p></div>
<h3 id="quick-tour-of-routesrb">2 Quick Tour of <tt>routes.rb</tt></h3>
<p>There are two components to routing in Rails: the routing engine itself, which is supplied as part of Rails, and the file <tt>config/routes.rb</tt>, which contains the actual routes that will be used by your application. Learning exactly what you can put in <tt>routes.rb</tt> is the main topic of this guide, but before we dig in let&#8217;s get a quick overview.</p>
<h4 id="processing-the-file">2.1 Processing the File</h4>
<p>In format, <tt>routes.rb</tt> is nothing more than one big block sent to <tt>ActionController::Routing::Routes.draw</tt>. Within this block, you can have comments, but it&#8217;s likely that most of your content will be individual lines of code &#8211; each line being a route in your application. You&#8217;ll find five main types of content in this file:</p>
<ul>
	<li>RESTful Routes</li>
	<li>Named Routes</li>
	<li>Nested Routes</li>
	<li>Regular Routes</li>
	<li>Default Routes</li>
</ul>
<p>Each of these types of route is covered in more detail later in this guide.</p>
<p>The <tt>routes.rb</tt> file is processed from top to bottom when a request comes in. The request will be dispatched to the first matching route. If there is no matching route, then Rails returns <span class="caps">HTTP</span> status 404 to the caller.</p>
<h4 id="restful-routes">2.2 RESTful Routes</h4>
<p>RESTful routes take advantage of the built-in <span class="caps">REST</span> orientation of Rails to wrap up a lot of routing information in a single declaration. A RESTful route looks like this:</p>
<div class="code_container"><code class="ruby">
map.resources :books
</code></div>
<h4 id="named-routes">2.3 Named Routes</h4>
<p>Named routes give you very readable links in your code, as well as handling incoming requests. Here&#8217;s a typical named route:</p>
<div class="code_container"><code class="ruby">
map.login '/login', :controller =&gt; 'sessions', :action =&gt; 'new'
</code></div>
<h4 id="nested-routes">2.4 Nested Routes</h4>
<p>Nested routes let you declare that one resource is contained within another resource. You&#8217;ll see later on how this translates to URLs and paths in your code. For example, if your application includes parts, each of which belongs to an assembly, you might have this nested route declaration:</p>
<div class="code_container"><code class="ruby">
map.resources :assemblies do |assemblies|
  assemblies.resources :parts
end
</code></div>
<h4 id="regular-routes">2.5 Regular Routes</h4>
<p>In many applications, you&#8217;ll also see non-RESTful routing, which explicitly connects the parts of a <span class="caps">URL</span> to a particular action. For example,</p>
<div class="code_container"><code class="ruby">
map.connect 'parts/:number', :controller =&gt; 'inventory', :action =&gt; 'show'
</code></div>
<h4 id="default-routes">2.6 Default Routes</h4>
<p>The default routes are a safety net that catch otherwise-unrouted requests. Many Rails applications will contain this pair of default routes:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
</code></div>
<p>These default routes are automatically generated when you create a new Rails application. If you&#8217;re using RESTful routing for everything in your application, you will probably want to remove them. But be sure you&#8217;re not using the default routes before you remove them!</p>
<h3 id="restful-routing-the-rails-default">3 RESTful Routing: the Rails Default</h3>
<p>RESTful routing is the current standard for routing in Rails, and it&#8217;s the one that you should prefer for new applications. It can take a little while to understand how RESTful routing works, but it&#8217;s worth the effort; your code will be easier to read and you&#8217;ll be working with Rails, rather than fighting against it, when you use this style of routing.</p>
<h4 id="what-is-rest">3.1 What is <span class="caps">REST</span>?</h4>
<p>The foundation of RESTful routing is generally considered to be Roy Fielding&#8217;s doctoral thesis, <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Architectural Styles and the Design of Network-based Software Architectures</a>. Fortunately, you need not read this entire document to understand how <span class="caps">REST</span> works in Rails. <span class="caps">REST</span>, an acronym for Representational State Transfer, boils down to two main principles for our purposes:</p>
<ul>
	<li>Using resource identifiers (which, for the purposes of discussion, you can think of as URLs) to represent resources</li>
	<li>Transferring representations of the state of that resource between system components.</li>
</ul>
<p>For example, to a Rails application a request such as this:</p>
<pre>
DELETE /photos/17
</pre>
<p>would be understood to refer to a photo resource with the ID of 17, and to indicate a desired action &#8211; deleting that resource. <span class="caps">REST</span> is a natural style for the architecture of web applications, and Rails makes it even more natural by using conventions to shield you from some of the RESTful complexities.</p>
<h4 id="crud-verbs-and-actions">3.2 <span class="caps">CRUD</span>, Verbs, and Actions</h4>
<p>In Rails, a RESTful route provides a mapping between <span class="caps">HTTP</span> verbs, controller actions, and (implicitly) <span class="caps">CRUD</span> operations in a database. A single entry in the routing file, such as</p>
<div class="code_container"><code class="ruby">
map.resources :photos
</code></div>
<p>creates seven different routes in your application:</p>
<table>
	<tr>
		<th><span class="caps">HTTP</span> verb</th>
		<th><span class="caps">URL</span>           </th>
		<th>controller</th>
		<th>action </th>
		<th>used for</th>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos         </td>
		<td>Photos      </td>
		<td>index    </td>
		<td>display a list of all photos</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/new     </td>
		<td>Photos      </td>
		<td>new      </td>
		<td>return an <span class="caps">HTML</span> form for creating a new photo</td>
	</tr>
	<tr>
		<td><span class="caps">POST</span>       </td>
		<td>/photos         </td>
		<td>Photos      </td>
		<td>create   </td>
		<td>create a new photo</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/1       </td>
		<td>Photos      </td>
		<td>show     </td>
		<td>display a specific photo</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/1/edit  </td>
		<td>Photos      </td>
		<td>edit     </td>
		<td>return an <span class="caps">HTML</span> form for editing a photo</td>
	</tr>
	<tr>
		<td><span class="caps">PUT</span>        </td>
		<td>/photos/1       </td>
		<td>Photos      </td>
		<td>update   </td>
		<td>update a specific photo</td>
	</tr>
	<tr>
		<td><span class="caps">DELETE</span>     </td>
		<td>/photos/1       </td>
		<td>Photos      </td>
		<td>destroy  </td>
		<td>delete a specific photo</td>
	</tr>
</table>
<p>For the specific routes (those that reference just a single resource), the identifier for the resource will be available within the corresponding controller action as <tt>params[:id]</tt>.</p>
<div class='info'><p>If you consistently use RESTful routes in your application, you should disable the default routes in <tt>routes.rb</tt> so that Rails will enforce the mapping between <span class="caps">HTTP</span> verbs and routes.</p></div>
<h4 id="urls-and-paths">3.3 URLs and Paths</h4>
<p>Creating a RESTful route will also make available a pile of helpers within your application:</p>
<ul>
	<li><tt>photos_url</tt> and <tt>photos_path</tt> map to the path for the index and create actions</li>
	<li><tt>new_photo_url</tt> and <tt>new_photo_path</tt> map to the path for the new action</li>
	<li><tt>edit_photo_url</tt> and <tt>edit_photo_path</tt> map to the path for the edit action</li>
	<li><tt>photo_url</tt> and <tt>photo_path</tt> map to the path for the show, update, and destroy actions</li>
</ul>
<div class='note'><p>Because routing makes use of the <span class="caps">HTTP</span> verb as well as the path in the request to dispatch requests, the seven routes generated by a RESTful routing entry only give rise to four pairs of helpers.</p></div>
<p>In each case, the <tt>_url</tt> helper generates a string containing the entire <span class="caps">URL</span> that the application will understand, while the <tt>_path</tt> helper generates a string containing the relative path from the root of the application. For example:</p>
<div class="code_container"><code class="ruby">
photos_url  # =&gt; &quot;http://www.example.com/photos&quot;
photos_path # =&gt; &quot;/photos&quot;
</code></div>
<h4 id="defining-multiple-resources-at-the-same-time">3.4 Defining Multiple Resources at the Same Time</h4>
<p>If you need to create routes for more than one RESTful resource, you can save a bit of typing by defining them all with a single call to <tt>map.resources</tt>:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :books, :videos
</code></div>
<p>This has exactly the same effect as</p>
<div class="code_container"><code class="ruby">
map.resources :photos
map.resources :books
map.resources :videos
</code></div>
<h4 id="singular-resources">3.5 Singular Resources</h4>
<p>You can also apply RESTful routing to singleton resources within your application. In this case, you use <tt>map.resource</tt> instead of <tt>map.resources</tt> and the route generation is slightly different. For example, a routing entry of</p>
<div class="code_container"><code class="ruby">
map.resource :geocoder
</code></div>
<p>creates six different routes in your application:</p>
<table>
	<tr>
		<th><span class="caps">HTTP</span> verb</th>
		<th><span class="caps">URL</span>           </th>
		<th>controller</th>
		<th>action </th>
		<th>used for</th>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/geocoder/new   </td>
		<td>Geocoders   </td>
		<td>new      </td>
		<td>return an <span class="caps">HTML</span> form for creating the new geocoder</td>
	</tr>
	<tr>
		<td><span class="caps">POST</span>       </td>
		<td>/geocoder       </td>
		<td>Geocoders   </td>
		<td>create   </td>
		<td>create the new geocoder</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/geocoder       </td>
		<td>Geocoders   </td>
		<td>show     </td>
		<td>display the one and only geocoder resource</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/geocoder/edit  </td>
		<td>Geocoders   </td>
		<td>edit     </td>
		<td>return an <span class="caps">HTML</span> form for editing the geocoder</td>
	</tr>
	<tr>
		<td><span class="caps">PUT</span>        </td>
		<td>/geocoder       </td>
		<td>Geocoders   </td>
		<td>update   </td>
		<td>update the one and only geocoder resource</td>
	</tr>
	<tr>
		<td><span class="caps">DELETE</span>     </td>
		<td>/geocoder       </td>
		<td>Geocoders   </td>
		<td>destroy  </td>
		<td>delete the geocoder resource</td>
	</tr>
</table>
<div class='note'><p>Even though the name of the resource is singular in <tt>routes.rb</tt>, the matching controller is still plural.</p></div>
<p>A singular RESTful route generates an abbreviated set of helpers:</p>
<ul>
	<li><tt>new_geocoder_url</tt> and <tt>new_geocoder_path</tt> map to the path for the new action</li>
	<li><tt>edit_geocoder_url</tt> and <tt>edit_geocoder_path</tt> map to the path for the edit action</li>
	<li><tt>geocoder_url</tt> and <tt>geocoder_path</tt> map to the path for the create, show, update, and destroy actions</li>
</ul>
<h4 id="customizing-resources">3.6 Customizing Resources</h4>
<p>Although the conventions of RESTful routing are likely to be sufficient for many applications, there are a number of ways to customize the way that RESTful routes work. These options include:</p>
<ul>
	<li><tt>:controller</tt></li>
	<li><tt>:singular</tt></li>
	<li><tt>:requirements</tt></li>
	<li><tt>:conditions</tt></li>
	<li><tt>:as</tt></li>
	<li><tt>:path_names</tt></li>
	<li><tt>:path_prefix</tt></li>
	<li><tt>:name_prefix</tt></li>
	<li><tt>:only</tt></li>
	<li><tt>:except</tt></li>
</ul>
<p>You can also add additional routes via the <tt>:member</tt> and <tt>:collection</tt> options, which are discussed later in this guide.</p>
<h5 id="using-controller">3.6.1 Using <tt>:controller</tt></h5>
<p>The <tt>:controller</tt> option lets you use a controller name that is different from the public-facing resource name. For example, this routing entry:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :controller =&gt; &quot;images&quot;
</code></div>
<p>will recognize incoming URLs containing <tt>photo</tt> but route the requests to the Images controller:</p>
<table>
	<tr>
		<th><span class="caps">HTTP</span> verb</th>
		<th><span class="caps">URL</span>           </th>
		<th>controller</th>
		<th>action </th>
		<th>used for</th>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos         </td>
		<td>Images      </td>
		<td>index    </td>
		<td>display a list of all images</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/new     </td>
		<td>Images      </td>
		<td>new      </td>
		<td>return an <span class="caps">HTML</span> form for creating a new image</td>
	</tr>
	<tr>
		<td><span class="caps">POST</span>       </td>
		<td>/photos         </td>
		<td>Images      </td>
		<td>create   </td>
		<td>create a new image</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/1       </td>
		<td>Images      </td>
		<td>show     </td>
		<td>display a specific image</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/photos/1/edit  </td>
		<td>Images      </td>
		<td>edit     </td>
		<td>return an <span class="caps">HTML</span> form for editing an image</td>
	</tr>
	<tr>
		<td><span class="caps">PUT</span>        </td>
		<td>/photos/1       </td>
		<td>Images      </td>
		<td>update   </td>
		<td>update a specific image</td>
	</tr>
	<tr>
		<td><span class="caps">DELETE</span>     </td>
		<td>/photos/1       </td>
		<td>Images      </td>
		<td>destroy  </td>
		<td>delete a specific image</td>
	</tr>
</table>
<div class='note'><p>The helpers will be generated with the name of the resource, not the name of the controller. So in this case, you&#8217;d still get <tt>photos_path</tt>, <tt>new_photo_path</tt>, and so on.</p></div>
<h4 id="controller-namespaces-and-routing">3.7 Controller Namespaces and Routing</h4>
<p>Rails allows you to group your controllers into namespaces by saving them in folders underneath <tt>app/controllers</tt>. The <tt>:controller</tt> option provides a convenient way to use these routes. For example, you might have a resource whose controller is purely for admin users in the <tt>admin</tt> folder:</p>
<div class="code_container"><code class="ruby">
map.resources :adminphotos, :controller =&gt; &quot;admin/photos&quot;
</code></div>
<p>If you use controller namespaces, you need to be aware of a subtlety in the Rails routing code: it always tries to preserve as much of the namespace from the previous request as possible. For example, if you are on a view generated from the <tt>adminphoto_path</tt> helper, and you follow a link generated with <tt>&lt;%= link_to "show", adminphoto(1) %&gt;</tt> you will end up on the view generated by <tt>admin/photos/show</tt>, but you will also end up in the same place if you have <tt>&lt;%= link_to "show", {:controller => "photos", :action => "show"} %&gt;</tt> because Rails will generate the show <span class="caps">URL</span> relative to the current <span class="caps">URL</span>.</p>
<div class='info'><p>If you want to guarantee that a link goes to a top-level controller, use a preceding slash to anchor the controller name: <tt>&lt;%= link_to "show", {:controller => "/photos", :action => "show"} %&gt;</tt></p></div>
<p>You can also specify a controller namespace with the <tt>:namespace</tt> option instead of a path:</p>
<div class="code_container"><code class="ruby">
map.resources :adminphotos, :namespace =&gt; &quot;admin&quot;, :controller =&gt; &quot;photos&quot;
</code></div>
<p>This can be especially useful when combined with <tt>with_options</tt> to map multiple namespaced routes together:</p>
<div class="code_container"><code class="ruby">
map.with_options(:namespace =&gt; &quot;admin&quot;) do |admin|
  admin.resources :photos, :videos
end
</code></div>
<p>That would give you routing for <tt>admin/photos</tt> and <tt>admin/videos</tt> controllers.</p>
<h5 id="using-singular">3.7.1 Using <tt>:singular</tt></h5>
<p>If for some reason Rails isn&#8217;t doing what you want in converting the plural resource name to a singular name in member routes, you can override its judgment with the <tt>:singular</tt> option:</p>
<div class="code_container"><code class="ruby">
map.resources :teeth, :singular =&gt; &quot;tooth&quot;
</code></div>
<div class='info'><p>Depending on the other code in your application, you may prefer to add additional rules to the <tt>Inflector</tt> class instead.</p></div>
<h5 id="using-requirements">3.7.2 Using <tt>:requirements</tt></h5>
<p>You can use the <tt>:requirements</tt> option in a RESTful route to impose a format on the implied <tt>:id</tt> parameter in the singular routes. For example:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :requirements =&gt; {:id =&gt; /[A-Z][A-Z][0-9]+/}
</code></div>
<p>This declaration constrains the <tt>:id</tt> parameter to match the supplied regular expression. So, in this case, <tt>/photos/1</tt> would no longer be recognized by this route, but <tt>/photos/RR27</tt> would.</p>
<h5 id="using-conditions">3.7.3 Using <tt>:conditions</tt></h5>
<p>Conditions in Rails routing are currently used only to set the <span class="caps">HTTP</span> verb for individual routes. Although in theory you can set this for RESTful routes, in practice there is no good reason to do so. (You&#8217;ll learn more about conditions in the discussion of classic routing later in this guide.)</p>
<h5 id="using-as">3.7.4 Using <tt>:as</tt></h5>
<p>The <tt>:as</tt> option lets you override the normal naming for the actual generated paths. For example:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :as =&gt; &quot;images&quot;
</code></div>
<p>will recognize incoming URLs containing <tt>image</tt> but route the requests to the Photos controller:</p>
<table>
	<tr>
		<th><span class="caps">HTTP</span> verb</th>
		<th><span class="caps">URL</span>           </th>
		<th>controller</th>
		<th>action </th>
		<td>_:used for</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/images         </td>
		<td>Photos      </td>
		<td>index    </td>
		<td>display a list of all photos</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/images/new     </td>
		<td>Photos      </td>
		<td>new      </td>
		<td>return an <span class="caps">HTML</span> form for creating a new photo</td>
	</tr>
	<tr>
		<td><span class="caps">POST</span>       </td>
		<td>/images         </td>
		<td>Photos      </td>
		<td>create   </td>
		<td>create a new photo</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/images/1       </td>
		<td>Photos      </td>
		<td>show     </td>
		<td>display a specific photo</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/images/1/edit  </td>
		<td>Photos      </td>
		<td>edit     </td>
		<td>return an <span class="caps">HTML</span> form for editing a photo</td>
	</tr>
	<tr>
		<td><span class="caps">PUT</span>        </td>
		<td>/images/1       </td>
		<td>Photos      </td>
		<td>update   </td>
		<td>update a specific photo</td>
	</tr>
	<tr>
		<td><span class="caps">DELETE</span>     </td>
		<td>/images/1       </td>
		<td>Photos      </td>
		<td>destroy  </td>
		<td>delete a specific photo</td>
	</tr>
</table>
<div class='note'><p>The helpers will be generated with the name of the resource, not the path name. So in this case, you&#8217;d still get <tt>photos_path</tt>, <tt>new_photo_path</tt>, and so on.</p></div>
<h5 id="using-path-names">3.7.5 Using <tt>:path_names</tt></h5>
<p>The <tt>:path_names</tt> option lets you override the automatically-generated &#8220;new&#8221; and &#8220;edit&#8221; segments in URLs:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :path_names =&gt; { :new =&gt; 'make', :edit =&gt; 'change' }
</code></div>
<p>This would cause the routing to recognize URLs such as</p>
<pre>
/photos/make
/photos/1/change
</pre>
<div class='note'><p>The actual action names aren&#8217;t changed by this option; the two URLs shown would still route to the new and edit actions.</p></div>
<div class='info'><p>If you find yourself wanting to change this option uniformly for all of your routes, you can set a default in your environment:</p></div>
<div class="code_container"><code class="ruby">
config.action_controller.resources_path_names = { :new =&gt; 'make', :edit =&gt; 'change' }
</code></div>
<h5 id="using-path-prefix">3.7.6 Using <tt>:path_prefix</tt></h5>
<p>The <tt>:path_prefix</tt> option lets you add additional parameters that will be prefixed to the recognized paths. For example, suppose each photo in your application belongs to a particular photographer. In that case, you might declare this route:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :path_prefix =&gt; '/photographers/:photographer_id'
</code></div>
<p>Routes recognized by this entry would include:</p>
<pre>
/photographers/1/photos/2
/photographers/1/photos
</pre>
<div class='note'><p>In most cases, it&#8217;s simpler to recognize URLs of this sort by creating nested resources, as discussed in the next section.</p></div>
<div class='note'><p>You can also use <tt>:path_prefix</tt> with non-RESTful routes.</p></div>
<h5 id="using-name-prefix">3.7.7 Using <tt>:name_prefix</tt></h5>
<p>You can use the :name_prefix option to avoid collisions between routes. This is most useful when you have two resources with the same name that use <tt>:path_prefix</tt> to map differently. For example:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :path_prefix =&gt; '/photographers/:photographer_id',
  :name_prefix =&gt; 'photographer_'
map.resources :photos, :path_prefix =&gt; '/agencies/:agency_id',
  :name_prefix =&gt; 'agency_'
</code></div>
<p>This combination will give you route helpers such as <tt>photographer_photos_path</tt> and <tt>agency_edit_photo_path</tt> to use in your code.</p>
<div class='note'><p>You can also use <tt>:name_prefix</tt> with non-RESTful routes.</p></div>
<h5 id="using-only-and-except">3.7.8 Using <tt>:only</tt> and <tt>:except</tt></h5>
<p>By default, Rails creates routes for all seven of the default actions (index, show, new, create, edit, update, and destroy) for every RESTful route in your application. You can use the <tt>:only</tt> and <tt>:except</tt> options to fine-tune this behavior. The <tt>:only</tt> option specifies that only certain routes should be generated:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :only =&gt; [:index, :show]
</code></div>
<p>With this declaration, a <tt>GET</tt> request to <tt>/photos</tt> would succeed, but a <tt>POST</tt> request to <tt>/photos</tt> (which would ordinarily be routed to the create action) will fail.</p>
<p>The <tt>:except</tt> option specifies a route or list of routes that should <em>not</em> be generated:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :except =&gt; :destroy
</code></div>
<p>In this case, all of the normal routes except the route for <tt>destroy</tt> (a <tt>DELETE</tt> request to <tt>/photos/<em>id</em></tt>) will be generated.</p>
<p>In addition to an action or a list of actions, you can also supply the special symbols <tt>:all</tt> or <tt>:none</tt> to the <tt>:only</tt> and <tt>:except</tt> options.</p>
<div class='info'><p>If your application has many RESTful routes, using <tt>:only</tt> and <tt>:except</tt> to generate only the routes that you actually need can cut down on memory use and speed up the routing process.</p></div>
<h4 id="nested-resources">3.8 Nested Resources</h4>
<p>It&#8217;s common to have resources that are logically children of other resources. For example, suppose your application includes these models:</p>
<div class="code_container"><code class="ruby">
class Magazine &lt; ActiveRecord::Base
  has_many :ads
end

class Ad &lt; ActiveRecord::Base
  belongs_to :magazine
end
</code></div>
<p>Each ad is logically subservient to one magazine. Nested routes allow you to capture this relationship in your routing. In this case, you might include this route declaration:</p>
<div class="code_container"><code class="ruby">
map.resources :magazines do |magazine|
  magazine.resources :ads
end
</code></div>
<div class='info'><p>Further below you&#8217;ll learn about a convenient shortcut for this construct:<br/><tt>map.resources :magazines, :has_many => :ads</tt></p></div>
<p>In addition to the routes for magazines, this declaration will also create routes for ads, each of which requires the specification of a magazine in the <span class="caps">URL</span>:</p>
<table>
	<tr>
		<th><span class="caps">HTTP</span> verb</th>
		<th><span class="caps">URL</span>                    </th>
		<th>controller</th>
		<th>action </th>
		<th>used for</th>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/magazines/1/ads         </td>
		<td>Ads         </td>
		<td>index    </td>
		<td>display a list of all ads for a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/magazines/1/ads/new     </td>
		<td>Ads         </td>
		<td>new      </td>
		<td>return an <span class="caps">HTML</span> form for creating a new ad belonging to a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">POST</span>       </td>
		<td>/magazines/1/ads         </td>
		<td>Ads         </td>
		<td>create   </td>
		<td>create a new ad belonging to a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/magazines/1/ads/1       </td>
		<td>Ads         </td>
		<td>show     </td>
		<td>display a specific ad belonging to a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">GET</span>        </td>
		<td>/magazines/1/ads/1/edit  </td>
		<td>Ads         </td>
		<td>edit     </td>
		<td>return an <span class="caps">HTML</span> form for editing an ad belonging to a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">PUT</span>        </td>
		<td>/magazines/1/ads/1       </td>
		<td>Ads         </td>
		<td>update   </td>
		<td>update a specific ad belonging to a specific magazine</td>
	</tr>
	<tr>
		<td><span class="caps">DELETE</span>     </td>
		<td>/magazines/1/ads/1       </td>
		<td>Ads         </td>
		<td>destroy  </td>
		<td>delete a specific ad belonging to a specific magazine</td>
	</tr>
</table>
<p>This will also create routing helpers such as <tt>magazine_ads_url</tt> and <tt>edit_magazine_ad_path</tt>.</p>
<h5 id="using-name-prefix">3.8.1 Using <tt>:name_prefix</tt></h5>
<p>The <tt>:name_prefix</tt> option overrides the automatically-generated prefix in nested route helpers. For example,</p>
<div class="code_container"><code class="ruby">
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix =&gt; 'periodical'
end
</code></div>
<p>This will create routing helpers such as <tt>periodical_ads_url</tt> and <tt>periodical_edit_ad_path</tt>. You can even use <tt>:name_prefix</tt> to suppress the prefix entirely:</p>
<div class="code_container"><code class="ruby">
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix =&gt; nil
end
</code></div>
<p>This will create routing helpers such as <tt>ads_url</tt> and <tt>edit_ad_path</tt>. Note that calling these will still require supplying an article id:</p>
<div class="code_container"><code class="ruby">
ads_url(@magazine)
edit_ad_path(@magazine, @ad)
</code></div>
<h5 id="using-has-one-and-has-many">3.8.2 Using <tt>:has_one</tt> and <tt>:has_many</tt></h5>
<p>The <tt>:has_one</tt> and <tt>:has_many</tt> options provide a succinct notation for simple nested routes. Use <tt>:has_one</tt> to nest a singleton resource, or <tt>:has_many</tt> to nest a plural resource:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :has_one =&gt; :photographer, :has_many =&gt; [:publications, :versions]
</code></div>
<p>This has the same effect as this set of declarations:</p>
<div class="code_container"><code class="ruby">
map.resources :photos do |photo|
  photo.resource :photographer
  photo.resources :publications
  photo.resources :versions
end
</code></div>
<h5 id="limits-to-nesting">3.8.3 Limits to Nesting</h5>
<p>You can nest resources within other nested resources if you like. For example:</p>
<div class="code_container"><code class="ruby">
map.resources :publishers do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
</code></div>
<p>However, without the use of <tt>name_prefix => nil</tt>, deeply-nested resources quickly become cumbersome. In this case, for example, the application would recognize URLs such as</p>
<pre>
/publishers/1/magazines/2/photos/3
</pre>
<p>The corresponding route helper would be <tt>publisher_magazine_photo_url</tt>, requiring you to specify objects at all three levels. Indeed, this situation is confusing enough that a popular <a href="http://weblog.jamisbuck.org/2007/2/5/nesting-resources">article</a> by Jamis Buck proposes a rule of thumb for good Rails design:</p>
<div class='info'><p><em>Resources should never be nested more than 1 level deep.</em></p></div>
<h5 id="shallow-nesting">3.8.4 Shallow Nesting</h5>
<p>The <tt>:shallow</tt> option provides an elegant solution to the difficulties of deeply-nested routes. If you specify this option at any level of routing, then paths for nested resources which reference a specific member (that is, those with an <tt>:id</tt> parameter) will not use the parent path prefix or name prefix. To see what this means, consider this set of routes:</p>
<div class="code_container"><code class="ruby">
map.resources :publishers, :shallow =&gt; true do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
</code></div>
<p>This will enable recognition of (among others) these routes:</p>
<pre>
/publishers/1           ==&gt; publisher_path(1)
/publishers/1/magazines ==&gt; publisher_magazines_path(1)
/magazines/2            ==&gt; magazine_path(2)
/magazines/2/photos     ==&gt; magazines_photos_path(2)
/photos/3               ==&gt; photo_path(3)
</pre>
<p>With shallow nesting, you need only supply enough information to uniquely identify the resource that you want to work with. If you like, you can combine shallow nesting with the <tt>:has_one</tt> and <tt>:has_many</tt> options:</p>
<div class="code_container"><code class="ruby">
map.resources :publishers, :has_many =&gt; { :magazines =&gt; :photos }, :shallow =&gt; true
</code></div>
<h4 id="route-generation-from-arrays">3.9 Route Generation from Arrays</h4>
<p>In addition to using the generated routing helpers, Rails can also generate RESTful routes from an array of parameters. For example, suppose you have a set of routes generated with these entries in routes.rb:</p>
<div class="code_container"><code class="ruby">
map.resources :magazines do |magazine|
  magazine.resources :ads
end
</code></div>
<p>Rails will generate helpers such as magazine_ad_path that you can use in building links:</p>
<div class="code_container"><code class="ruby">
&lt;%= link_to &quot;Ad details&quot;, magazine_ad_path(@magazine, @ad) %&gt;
</code></div>
<p>Another way to refer to the same route is with an array of objects:</p>
<div class="code_container"><code class="ruby">
&lt;%= link_to &quot;Ad details&quot;, [@magazine, @ad] %&gt;
</code></div>
<p>This format is especially useful when you might not know until runtime which of several types of object will be used in a particular link.</p>
<h4 id="namespaced-resources">3.10 Namespaced Resources</h4>
<p>It&#8217;s possible to do some quite complex things by combining <tt>:path_prefix</tt> and <tt>:name_prefix</tt>. For example, you can use the combination of these two options to move administrative resources to their own folder in your application:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :path_prefix =&gt; 'admin', :controller =&gt; 'admin/photos'
map.resources :tags, :name_prefix =&gt; 'admin_photo_', :path_prefix =&gt; 'admin/photos/:photo_id', :controller =&gt; 'admin/photo_tags'
map.resources :ratings, :name_prefix =&gt; 'admin_photo_', :path_prefix =&gt; 'admin/photos/:photo_id', :controller =&gt; 'admin/photo_ratings'
</code></div>
<p>The good news is that if you find yourself using this level of complexity, you can stop. Rails supports <em>namespaced resources</em> to make placing resources in their own folder a snap. Here&#8217;s the namespaced version of those same three routes:</p>
<div class="code_container"><code class="ruby">
map.namespace(:admin) do |admin|
	admin.resources :photos,
	  :has_many =&gt; { :tags, :ratings}
end
</code></div>
<p>As you can see, the namespaced version is much more succinct than the one that spells everything out &#8211; but it still creates the same routes. For example, you&#8217;ll get <tt>admin_photos_url</tt> that expects to find an <tt>Admin::PhotosController</tt> and that matches <tt>admin/photos</tt>, and <tt>admin_photos_ratings_path</tt> that matches <tt>/admin/photos/_photo_id_/ratings</tt>, expecting to use <tt>Admin::RatingsController</tt>. Even though you&#8217;re not specifying <tt>path_prefix</tt> explicitly, the routing code will calculate the appropriate <tt>path_prefix</tt> from the route nesting.</p>
<h4 id="adding-more-restful-actions">3.11 Adding More RESTful Actions</h4>
<p>You are not limited to the seven routes that RESTful routing creates by default. If you like, you may add additional member routes (those which apply to a single instance of the resource), additional new routes (those that apply to creating a new resource), or additional collection routes (those which apply to the collection of resources as a whole).</p>
<h5 id="adding-member-routes">3.11.1 Adding Member Routes</h5>
<p>To add a member route, use the <tt>:member</tt> option:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :member =&gt; { :preview =&gt; :get }
</code></div>
<p>This will enable Rails to recognize URLs such as <tt>/photos/1/preview</tt> using the <span class="caps">GET</span> <span class="caps">HTTP</span> verb, and route them to the preview action of the Photos controller. It will also create the <tt>preview_photo_url</tt> and <tt>preview_photo_path</tt> route helpers.</p>
<p>Within the hash of member routes, each route name specifies the <span class="caps">HTTP</span> verb that it will recognize. You can use <tt>:get</tt>, <tt>:put</tt>, <tt>:post</tt>, <tt>:delete</tt>, or <tt>:any</tt> here. You can also specify an array of methods, if you need more than one but you don&#8217;t want to allow just anything:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :member =&gt; { :prepare =&gt; [:get, :post] }
</code></div>
<h5 id="adding-collection-routes">3.11.2 Adding Collection Routes</h5>
<p>To add a collection route, use the <tt>:collection</tt> option:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :collection =&gt; { :search =&gt; :get }
</code></div>
<p>This will enable Rails to recognize URLs such as <tt>/photos/search</tt> using the <span class="caps">GET</span> <span class="caps">HTTP</span> verb, and route them to the search action of the Photos controller. It will also create the <tt>search_photos_url</tt> and <tt>search_photos_path</tt> route helpers.</p>
<p>Just as with member routes, you can specify an array of methods for a collection route:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :collection =&gt; { :search =&gt; [:get, :post] }
</code></div>
<h5 id="adding-new-routes">3.11.3 Adding New Routes</h5>
<p>To add a new route (one that creates a new resource), use the <tt>:new</tt> option:</p>
<div class="code_container"><code class="ruby">
map.resources :photos, :new =&gt; { :upload =&gt; :post }
</code></div>
<p>This will enable Rails to recognize URLs such as <tt>/photos/new/upload</tt> using the <span class="caps">POST</span> <span class="caps">HTTP</span> verb, and route them to the upload action of the Photos controller. It will also create the <tt>upload_new_photos_path</tt> and <tt>upload_new_photos_url</tt> route helpers.</p>
<div class='info'><p>If you want to redefine the verbs accepted by one of the standard actions, you can do so by explicitly mapping that action. For example:<br/><tt>map.resources :photos, :new => { :new => :any }</tt><br/>This will allow the new action to be invoked by any request to <tt>photos/new</tt>, no matter what <span class="caps">HTTP</span> verb you use.</p></div>
<h5 id="a-note-of-caution">3.11.4 A Note of Caution</h5>
<p>If you find yourself adding many extra actions to a RESTful route, it&#8217;s time to stop and ask yourself whether you&#8217;re disguising the presence of another resource that would be better split off on its own. When the <tt>:member</tt> and <tt>:collection</tt> hashes become a dumping-ground, RESTful routes lose the advantage of easy readability that is one of their strongest points.</p>
<h3 id="regular-routes">4 Regular Routes</h3>
<p>In addition to RESTful routing, Rails supports regular routing &#8211; a way to map URLs to controllers and actions. With regular routing, you don&#8217;t get the masses of routes automatically generated by RESTful routing. Instead, you must set up each route within your application separately.</p>
<p>While RESTful routing has become the Rails standard, there are still plenty of places where the simpler regular routing works fine. You can even mix the two styles within a single application. In general, you should prefer RESTful routing <em>when possible</em>, because it will make parts of your application easier to write. But there&#8217;s no need to try to shoehorn every last piece of your application into a RESTful framework if that&#8217;s not a good fit.</p>
<h4 id="bound-parameters">4.1 Bound Parameters</h4>
<p>When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming <span class="caps">HTTP</span> request. Two of these symbols are special: <tt>:controller</tt> maps to the name of a controller in your application, and <tt>:action</tt> maps to the name of an action within that controller. For example, consider one of the default Rails routes:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id'
</code></div>
<p>If an incoming request of <tt>/photos/show/1</tt> is processed by this route (because it hasn&#8217;t matched any previous route in the file), then the result will be to invoke the <tt>show</tt> action of the <tt>Photos</tt> controller, and to make the final parameter (1) available as <tt>params[:id]</tt>.</p>
<h4 id="wildcard-components">4.2 Wildcard Components</h4>
<p>You can set up as many wildcard symbols within a regular route as you like. Anything other than <tt>:controller</tt> or <tt>:action</tt> will be available to the matching action as part of the params hash. So, if you set up this route:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id/:user_id'
</code></div>
<p>An incoming <span class="caps">URL</span> of <tt>/photos/show/1/2</tt> will be dispatched to the <tt>show</tt> action of the <tt>Photos</tt> controller. <tt>params[:id]</tt> will be set to 1, and <tt>params[:user_id]</tt> will be set to 2.</p>
<h4 id="static-text">4.3 Static Text</h4>
<p>You can specify static text when creating a route. In this case, the static text is used only for matching the incoming requests:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id/with_user/:user_id'
</code></div>
<p>This route would respond to URLs such as <tt>/photos/show/1/with_user/2</tt>.</p>
<h4 id="querystring-parameters">4.4 Querystring Parameters</h4>
<p>Rails routing automatically picks up querystring parameters and makes them available in the <tt>params</tt> hash. For example, with this route:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id'
</code></div>
<p>An incoming <span class="caps">URL</span> of <tt>/photos/show/1?user_id=2</tt> will be dispatched to the <tt>show</tt> action of the <tt>Photos</tt> controller. <tt>params[:id]</tt> will be set to 1, and <tt>params[:user_id]</tt> will be equal to 2.</p>
<h4 id="defining-defaults">4.5 Defining Defaults</h4>
<p>You do not need to explicitly use the <tt>:controller</tt> and <tt>:action</tt> symbols within a route. You can supply defaults for these two parameters in a hash:</p>
<div class="code_container"><code class="ruby">
map.connect 'photos/:id', :controller =&gt; 'photos', :action =&gt; 'show'
</code></div>
<p>With this route, an incoming <span class="caps">URL</span> of <tt>/photos/12</tt> would be dispatched to the <tt>show</tt> action within the <tt>Photos</tt> controller.</p>
<p>You can also define other defaults in a route by supplying a hash for the <tt>:defaults</tt> option. This even applies to parameters that are not explicitly defined elsewhere in the route. For example:</p>
<div class="code_container"><code class="ruby">
map.connect 'photos/:id', :controller =&gt; 'photos', :action =&gt; 'show',
  :defaults =&gt; { :format =&gt; 'jpg' }
</code></div>
<p>With this route, an incoming <span class="caps">URL</span> of <tt>photos/12</tt> would be dispatched to the <tt>show</tt> action within the <tt>Photos</tt> controller, and <tt>params[:format]</tt> will be set to <tt>jpg</tt>.</p>
<h4 id="named-routes">4.6 Named Routes</h4>
<p>Regular routes need not use the <tt>connect</tt> method. You can use any other name here to create a <em>named route</em>. For example,</p>
<div class="code_container"><code class="ruby">
map.logout '/logout', :controller =&gt; 'sessions', :action =&gt; 'destroy'
</code></div>
<p>This will do two things. First, requests to <tt>/logout</tt> will be sent to the <tt>destroy</tt> action of the <tt>Sessions</tt> controller. Second, Rails will maintain the <tt>logout_path</tt> and <tt>logout_url</tt> helpers for use within your code.</p>
<h4 id="route-requirements">4.7 Route Requirements</h4>
<p>You can use the <tt>:requirements</tt> option to enforce a format for any parameter in a route:</p>
<div class="code_container"><code class="ruby">
map.connect 'photo/:id', :controller =&gt; 'photos', :action =&gt; 'show',
 :requirements =&gt; { :id =&gt; /[A-Z]\d{5}/ }
</code></div>
<p>This route would respond to URLs such as <tt>/photo/A12345</tt>. You can more succinctly express the same route this way:</p>
<div class="code_container"><code class="ruby">
map.connect 'photo/:id', :controller =&gt; 'photos', :action =&gt; 'show',
  :id =&gt; /[A-Z]\d{5}/
</code></div>
<h4 id="route-conditions">4.8 Route Conditions</h4>
<p>Route conditions (introduced with the <tt>:conditions</tt> option) are designed to implement restrictions on routes. Currently, the only supported restriction is <tt>:method</tt>:</p>
<div class="code_container"><code class="ruby">
map.connect 'photo/:id', :controller =&gt; 'photos', :action =&gt; 'show',
 :conditions =&gt; { :method =&gt; :get }
</code></div>
<p>As with conditions in RESTful routes, you can specify <tt>:get</tt>, <tt>:post</tt>, <tt>:put</tt>, <tt>:delete</tt>, or <tt>:any</tt> for the acceptable method.</p>
<h4 id="route-globbing">4.9 Route Globbing</h4>
<p>Route globbing is a way to specify that a particular parameter should be matched to all the remaining parts of a route. For example</p>
<div class="code_container"><code class="ruby">
map.connect 'photo/*other', :controller =&gt; 'photos', :action =&gt; 'unknown',
</code></div>
<p>This route would match <tt>photo/12</tt> or <tt>/photo/long/path/to/12</tt> equally well, creating an array of path segments as the value of <tt>params[:other]</tt>.</p>
<h4 id="route-options">4.10 Route Options</h4>
<p>You can use <tt>:with_options</tt> to simplify defining groups of similar routes:</p>
<div class="code_container"><code class="ruby">
map.with_options :controller =&gt; 'photo' do |photo|
  photo.list '', :action =&gt; 'index'
  photo.delete ':id/delete', :action =&gt; 'delete'
  photo.edit ':id/edit', :action =&gt; 'edit'
end
</code></div>
<p>The importance of <tt>map.with_options</tt> has declined with the introduction of RESTful routes.</p>
<h3 id="formats-and-respond-to">5 Formats and <tt>respond_to</tt></h3>
<p>There&#8217;s one more way in which routing can do different things depending on differences in the incoming <span class="caps">HTTP</span> request: by issuing a response that corresponds to what the request specifies that it will accept. In Rails routing, you can control this with the special <tt>:format</tt> parameter in the route.</p>
<p>For instance, consider the second of the default routes in the boilerplate <tt>routes.rb</tt> file:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id.:format'
</code></div>
<p>This route matches requests such as <tt>/photo/edit/1.xml</tt> or <tt>/photo/show/2.rss</tt>. Within the appropriate action code, you can issue different responses depending on the requested format:</p>
<div class="code_container"><code class="ruby">
respond_to do |format|
  format.html # return the default template for HTML
  format.xml { render :xml =&gt; @photo.to_xml }
end
</code></div>
<h4 id="specifying-the-format-with-an-http-header">5.1 Specifying the Format with an <span class="caps">HTTP</span> Header</h4>
<p>If there is no <tt>:format</tt> parameter in the route, Rails will automatically look at the <span class="caps">HTTP</span> Accept header to determine the desired format.</p>
<h4 id="recognized-mime-types">5.2 Recognized <span class="caps">MIME</span> types</h4>
<p>By default, Rails recognizes <tt>html</tt>, <tt>text</tt>, <tt>json</tt>, <tt>csv</tt>, <tt>xml</tt>, <tt>rss</tt>, <tt>atom</tt>, and <tt>yaml</tt> as acceptable response types. If you need types beyond this, you can register them in your environment:</p>
<div class="code_container"><code class="ruby">
Mime::Type.register &quot;image/jpg&quot;, :jpg
</code></div>
<h3 id="the-default-routes">6 The Default Routes</h3>
<p>When you create a new Rails application, <tt>routes.rb</tt> is initialized with two default routes:</p>
<div class="code_container"><code class="ruby">
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
</code></div>
<p>These routes provide reasonable defaults for many URLs, if you&#8217;re not using RESTful routing.</p>
<div class='note'><p>The default routes will make every action of every controller in your application accessible to <span class="caps">GET</span> requests. If you&#8217;ve designed your application to make consistent use of RESTful and named routes, you should comment out the default routes to prevent access to your controllers through the wrong verbs. If you&#8217;ve had the default routes enabled during development, though, you need to be sure that you haven&#8217;t unwittingly depended on them somewhere in your application &#8211; otherwise you may find mysterious failures when you disable them.</p></div>
<h3 id="the-empty-route">7 The Empty Route</h3>
<p>Don&#8217;t confuse the default routes with the empty route. The empty route has one specific purpose: to route requests that come in to the root of the web site. For example, if your site is example.com, then requests to <tt>http://example.com</tt> or <tt>http://example.com/</tt> will be handled by the empty route.</p>
<h4 id="using-maproot">7.1 Using <tt>map.root</tt></h4>
<p>The preferred way to set up the empty route is with the <tt>map.root</tt> command:</p>
<div class="code_container"><code class="ruby">
map.root :controller =&gt; &quot;pages&quot;, :action =&gt; &quot;main&quot;
</code></div>
<p>The use of the <tt>root</tt> method tells Rails that this route applies to requests for the root of the site.</p>
<p>For better readability, you can specify an already-created route in your call to <tt>map.root</tt>:</p>
<div class="code_container"><code class="ruby">
map.index 'index', :controller =&gt; &quot;pages&quot;, :action =&gt; &quot;main&quot;
map.root :index
</code></div>
<p>Because of the top-down processing of the file, the named route must be specified <em>before</em> the call to <tt>map.root</tt>.</p>
<h4 id="connecting-the-empty-string">7.2 Connecting the Empty String</h4>
<p>You can also specify an empty route by explicitly connecting the empty string:</p>
<div class="code_container"><code class="ruby">
map.connect '', :controller =&gt; &quot;pages&quot;, :action =&gt; &quot;main&quot;
</code></div>
<div class='info'><p>If the empty route does not seem to be working in your application, make sure that you have deleted the file <tt>public/index.html</tt> from your Rails tree.</p></div>
<h3 id="inspecting-and-testing-routes">8 Inspecting and Testing Routes</h3>
<p>Routing in your application should not be a &#8220;black box&#8221; that you never open. Rails offers built-in tools for both inspecting and testing routes.</p>
<h4 id="seeing-existing-routes-with-rake">8.1 Seeing Existing Routes with <tt>rake</tt></h4>
<p>If you want a complete list of all of the available routes in your application, run the <tt>rake routes</tt> command. This will dump all of your routes to the console, in the same order that they appear in <tt>routes.rb</tt>. For each route, you&#8217;ll see:</p>
<ul>
	<li>The route name (if any)</li>
	<li>The <span class="caps">HTTP</span> verb used (if the route doesn&#8217;t respond to all verbs)</li>
	<li>The <span class="caps">URL</span> pattern</li>
	<li>The routing parameters that will be generated by this <span class="caps">URL</span></li>
</ul>
<p>For example, here&#8217;s a small section of the <tt>rake routes</tt> output for a RESTful route:</p>
<pre>
          users GET  /users          {:controller=&gt;"users", :action=&gt;"index"}
formatted_users GET  /users.:format  {:controller=&gt;"users", :action=&gt;"index"}
                POST /users          {:controller=&gt;"users", :action=&gt;"create"}
                POST /users.:format  {:controller=&gt;"users", :action=&gt;"create"}
</pre>
<div class='info'><p>You&#8217;ll find that the output from <tt>rake routes</tt> is much more readable if you widen your terminal window until the output lines don&#8217;t wrap.</p></div>
<h4 id="testing-routes">8.2 Testing Routes</h4>
<p>Routes should be included in your testing strategy (just like the rest of your application). Rails offers three <a href="http://api.rubyonrails.org/classes/ActionController/Assertions/RoutingAssertions.html">built-in assertions</a> designed to make testing routes simpler:</p>
<ul>
	<li><tt>assert_generates</tt></li>
	<li><tt>assert_recognizes</tt></li>
	<li><tt>assert_routing</tt></li>
</ul>
<h5 id="the-assert-generates-assertion">8.2.1 The <tt>assert_generates</tt> Assertion</h5>
<p>Use <tt>assert_generates</tt> to assert that a particular set of options generate a particular path. You can use this with default routes or custom routes</p>
<div class="code_container"><code class="ruby">
assert_generates &quot;/photos/1&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot;, :id =&gt; &quot;1&quot; }
assert_generates &quot;/about&quot;, :controller =&gt; &quot;pages&quot;, :action =&gt; &quot;about&quot;
</code></div>
<h5 id="the-assert-recognizes-assertion">8.2.2 The <tt>assert_recognizes</tt> Assertion</h5>
<p>The <tt>assert_recognizes</tt> assertion is the inverse of <tt>assert_generates</tt>. It asserts that Rails recognizes the given path and routes it to a particular spot in your application.</p>
<div class="code_container"><code class="ruby">
assert_recognizes { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot;, :id =&gt; &quot;1&quot; }, &quot;/photos/1&quot;
</code></div>
<p>You can supply a <tt>:method</tt> argument to specify the <span class="caps">HTTP</span> verb:</p>
<div class="code_container"><code class="ruby">
assert_recognizes { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;create&quot; }, { :path =&gt; &quot;photos&quot;, :method =&gt; :post }
</code></div>
<p>You can also use the RESTful helpers to test recognition of a RESTful route:</p>
<div class="code_container"><code class="ruby">
assert_recognizes new_photo_url, { :path =&gt; &quot;photos&quot;, :method =&gt; :post }
</code></div>
<h5 id="the-assert-routing-assertion">8.2.3 The <tt>assert_routing</tt> Assertion</h5>
<p>The <tt>assert_routing</tt> assertion checks the route both ways: it tests that the path generates the options, and that the options generate the path. Thus, it combines the functions of <tt>assert_generates</tt> and <tt>assert_recognizes</tt>.</p>
<div class="code_container"><code class="ruby">
assert_routing { :path =&gt; &quot;photos&quot;, :method =&gt; :post }, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;create&quot; }
</code></div>
<h3 id="changelog">9 Changelog</h3>
<p><a href="http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/3">Lighthouse ticket</a></p>
<ul>
	<li>October 4, 2008: Added additional detail on specifying verbs for resource member/collection routes, by <a href="credits.html#mgunderloy">Mike Gunderloy</a></li>
	<li>September 23, 2008: Added section on namespaced controllers and routing, by <a href="credits.html#mgunderloy">Mike Gunderloy</a></li>
	<li>September 10, 2008: initial version by <a href="credits.html#mgunderloy">Mike Gunderloy</a></li>
</ul>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</a></p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>
</body>
</html>
